#lang racket
(require rackunit)
(require math/number-theory)
(require math/base)

; ********************************************************************
; moduler exponentiation
; b = base
; p = power
; m = modulo
(define (mod-expt b p m)
  (let loop ([result 1] [pow p] [base b])
    (if (> pow 0)
        (loop (if (odd? pow)
                  (modulo (* result base) m)
                  result)
              (arithmetic-shift pow -1)
              (modulo (sqr base) m))
        result)))

(check-equal? (mod-expt 2 9 3) (modulo (expt 2 9) 3))
(check-equal? (mod-expt 7 100 11) (modulo (expt 7 100) 11))
(check-equal? (mod-expt 1 1000 4) (modulo (expt 1 1000) 4))
(check-equal? (mod-expt 47 44 11) (modulo (expt 47 44) 11))

